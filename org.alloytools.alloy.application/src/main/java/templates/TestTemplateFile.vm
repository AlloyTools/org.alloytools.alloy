from __future__ import annotations
from operator import methodcaller
import logging
import random
from abc import ABC


# ===== logging =====

GCLOG = logging.DEBUG+1  # used for guard condition
ACLOG = logging.DEBUG+2  # used for action chosen
CALOG = logging.DEBUG+3  # used for feedback on adding called

logging.basicConfig(level=ACLOG)
logging.addLevelName(GCLOG, "GUARD")
logging.addLevelName(ACLOG, "ACTION")
logging.addLevelName(CALOG, "CALLED")\

# ===== Base Classes =====

class State(ABC):
    """" State base class """

    def __init__(self, *args) -> None:
        """
        State() => doesn't do anything
        State(context: State) => set _context to context
        State(context: State, root_context: State) => also set root context
        """

        if len(args) >= 2 and isinstance(args[1], State):
            self._set_root_context(args[1])
        if len(args) >= 1 and isinstance(args[0], State):
            self._set_context(args[0])

    def __repr__(self):
        return f"State {self.__class__.__name__}"

    def _set_context(self, context: State):
        self._context = context

    def _set_root_context(self, context: State):
        self._root_context = context

    def change_state(self, state: State):
        logging.info(f"{self._state} => {state}")
        self._state = state

class Signature(ABC):
    def __init__(self, sig_name: str = "Signature", name: str = None) -> None:
        if name is None:
            self._name = self.__class__.__name__
        else:
            self._name = name
        self._sig_name = sig_name

    def __repr__(self):
        return f"{self._sig_name} {self._name}"

    def __key(self):
        return self._sig_name + self._name

    def __hash__(self):
        return hash(self.__key())

    def __eq__(self, other):
        if isinstance(other, Signature):
            return self.__key() == other.__key()
        return False


# Model "one sig" as singleton classes
class Singleton(type(Signature)):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
        cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

# --- Signatures ---

#foreach($label in $basicSigLabels)
class $label(Signature):
    def __init__(self, name: str = None) -> None:
        super().__init__("${label}", name)

#end

#foreach($label in $oneSigLabels)
class $label(Signature, metaclass=Singleton):
    def __init__(self):
        self._abbrev = '${label.charAt(0)}'

    def __repr__(self):
        return f"$label(${label.charAt(0)})"


#end


# --- Conc States ---
#macro(generateState $concState $padding)
$padding class ${concState.getName()}_State(State):
$padding     # substates
	#foreach($substate in $concState.getSubstates())
		#set($tab = "    ")
		#set($newpadding = "$padding$tab")
		#generateState($substate $newpadding)
	#end
	
$padding    """ The wrapper state for ${concState.getName()} """

$padding    def __init__(self, context: State, root_context: State) -> None:
$padding        self._state = self.${concState.getName()}(self, root_context)  # default state


$padding    class ${concState.getName()}(State):
$padding        """ the concrete state that does the work """

$padding        # transitions
       #foreach($trans in $concState.getTransitions())
$padding        # trans - ${trans.getTransName()}
$padding       def _trans_${trans.getTransName()}(self, is_event: bool) -> bool:
$padding            r""" Execute a transition if possible
$padding            :param is_event: is it triggered by event?
$padding            :return: false to continue the loop in the executor
$padding                     true to stop the loop
$padding            """
$padding            /** TODO: global variables (signatures used in this state)*/
$padding            #foreach($globalVar in $globalVariables)
$padding            global ${globalVar}
                    #end

$padding            if (is_event):
$padding                return False
$padding            else:
$padding                logging.log(GCLOG, f" test guard condition of ${trans.getTransName()}.")
$padding                /** TODO: transition guard condition */
$padding                if not (${trans.getGuardCondition()}):
$padding                    return False

$padding            logging.log(ACLOG,f" action of [${trans.getTransName()}] triggered.")
$padding            /** TODO: transition action */
$padding            ${trans.getAction()}

$padding            self._context.change_state(self._context.${trans.getFromStateName()}(self._context, self._root_context))
$padding            return True

        #end
 
#end 

#foreach($concState in $concStateList)
	#generateState($concState "")
#end


