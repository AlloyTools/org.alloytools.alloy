from abc import ABC

class Signature(ABC):
    def __init__(self, sig_name: str = "Signature", name: str = None) -> None:
        if name is None:
            self._name = self.__class__.__name__
        else:
            self._name = name
        self._sig_name = sig_name

    def __repr__(self):
        return f"{self._sig_name} {self._name}"

    def __key(self):
        return self._sig_name + self._name

    def __hash__(self):
        return hash(self.__key())

    def __eq__(self, other):
        if isinstance(other, Signature):
            return self.__key() == other.__key()
        return False


# Model "one sig" as singleton classes
class Singleton(type(Signature)):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
        cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

# --- Signatures ---

#foreach($label in $basicSigLabels)
class $label(Signature):
    def __init__(self, name: str = None) -> None:
        super().__init__("${label}", name)

#end

#foreach($label in $oneSigLabels)
class $label(Signature, metaclass=Singleton):
    def __init__(self):
        self._abbrev = '${label.charAt(0)}'

    def __repr__(self):
        return f"$label(${label.charAt(0)})"


#end


# --- Conc States ---
#macro(generateState $concState $padding)
$padding class ${concState.getName()}_State(State):
$padding     # substates
	#foreach($substate in $concState.getSubstates())
		#set($tab = "    ")
		#set($newpadding = "$padding$tab")
		#generateState($substate $newpadding)
	#end
	
$padding    """ The wrapper state for ${concState.getName()} """

$padding    def __init__(self, context: State, root_context: State) -> None:
$padding        self._state = self.${concState.getName()}(self, root_context)  # default state


$padding    class ${concState.getName()}(State):
$padding        """ the concrete state that does the work """

$padding        # transitions
       #foreach($trans in $concState.getTransitions())
$padding        # trans - ${trans.getTransName()}
$padding       def _trans_${trans.getTransName()}(self, is_event: bool) -> bool:
$padding            r""" Execute a transition if possible
$padding            :param is_event: is it triggered by event?
$padding            :return: false to continue the loop in the executor
$padding                     true to stop the loop
$padding            """
$padding            /** TODO: global variables (signatures used in this state)*/
$padding            #foreach($globalVar in $globalVariables)
$padding            global ${globalVar}
            #end


$padding            if (is_event):
$padding                return False
$padding            else:
$padding                logging.log(GCLOG, f" test guard condition of ${trans.getTransName()}.")
$padding                /** TODO: transition guard condition */
$padding                if not len(${trans.getGuardCondition()}):
$padding                    return False

$padding            logging.log(ACLOG,f" action of [${trans.getTransName()}] triggered.")
$padding            /** TODO: transition action */
$padding            ${trans.getAction()}

$padding            self._context.change_state(self._context.${trans.fromStateName()}(self._context, self._root_context))
$padding            return True

        #end
 
#end 

#foreach($concState in $concStateList)
	#generateState($concState "")
#end


