 

//DASH grammar ------------------------------------------------------------------------

// besides creating a DashState; the parsing also has count buffers and create indexes
// for those buffers in order to have the correct open statements

// no DashErrors here -- all are checked in wff checks

// adding a case for the Spec
Spec ::= Spec StateRoot:o ;

// Root State Declaration
StateRoot ::= STATE:o Name:n LBRACE RBRACE:e // empty state
        {: 
           // first line in file is line 1
           parser.dashmodule.rootStartLine = o.y;
           parser.dashmodule.rootEndLine = e.y;
           parser.dashmodule.addRoot(
                new DashState(o, 
                        n.label,
                        DashState.noParam(), 
                        DashStrings.StateKind.OR,  
                        DashStrings.DefKind.NOTDEFAULT, 
                        DashState.noSubstates()));
        :}; 
StateRoot ::= STATE:o Name:n LBRACE StateItemList:c RBRACE:e 
       {: 
          parser.dashmodule.rootStartLine = o.y;
          parser.dashmodule.rootEndLine = e.y;
          parser.dashmodule.addRoot(
                new DashState(o, 
                        n.label, 
                        null,
                        DashStrings.StateKind.OR, 
                        DashStrings.DefKind.NOTDEFAULT, 
                        c));
       :};

StateItemList ::= StateItem:x
        {: List<Object> xList = new ArrayList<Object>(); xList.add(x); RESULT= xList; :};
StateItemList ::= StateItemList:c StateItem:s 
        {: c.add(s); RESULT = c; :};

// or-state, non-default, empty
StateItem ::= STATE:o  Name:n LBRACE RBRACE 
        {: RESULT = new DashState(o, 
                n.label, 
                DashState.noParam(),
                DashStrings.StateKind.OR,
                DashStrings.DefKind.NOTDEFAULT,
                DashState.noSubstates() ); 
        :}; 

// or-state, non-default, substates
StateItem ::= STATE:o Name:n LBRACE StateItemList:c RBRACE 
        {: RESULT = new DashState(o, 
                n.label,  
                DashState.noParam(), 
                DashStrings.StateKind.OR,
                DashStrings.DefKind.NOTDEFAULT, 
                c);    
        :};

// or-state, default, empty state
StateItem ::= DEF STATE:o Name:n LBRACE RBRACE 
        {: RESULT = new DashState(o, 
                n.label,
                DashState.noParam(), 
                DashStrings.StateKind.OR,
                DashStrings.DefKind.DEFAULT,
                DashState.noSubstates());   
        :}; 

// or-state, default, substates
StateItem ::= DEF STATE:o Name:n LBRACE StateItemList:c RBRACE 
        {:  RESULT = new DashState(o, 
                n.label, 
                DashState.noParam(),
                DashStrings.StateKind.OR,
                DashStrings.DefKind.DEFAULT, 
                c);   
        :};

// conc state, non-default, empty
StateItem ::= CONC:o  Name:n LBRACE  RBRACE 
        {: RESULT = new DashState(o, 
                n.label, 
                DashState.noParam(), 
                DashStrings.StateKind.AND,
                DashStrings.DefKind.NOTDEFAULT, 
                DashState.noSubstates());  
        :};

// conc state, non-default, substates
StateItem ::= CONC:o  Name:n LBRACE StateItemList:c RBRACE 
        {: RESULT = new DashState(o, 
                n.label, 
                DashState.noParam(),
                DashStrings.StateKind.AND, 
                DashStrings.DefKind.NOTDEFAULT, 
                c);  
        :};

// conc state, default, empty
StateItem ::= DEF CONC:o  Name:n LBRACE  RBRACE 
        {: RESULT = new DashState(o, 
                n.label,
                DashState.noParam(), 
                DashStrings.StateKind.AND, 
                DashStrings.DefKind.DEFAULT, 
                DashState.noSubstates() );  
        :};

// conc state, default, substates
StateItem ::= DEF CONC:o  Name:n LBRACE StateItemList:c RBRACE 
        {: RESULT = new DashState(o,
                n.label, 
                DashState.noParam(),
                DashStrings.StateKind.AND, 
                DashStrings.DefKind.DEFAULT, 
                c);  
        :};

// parametrized state, non-default, empty
StateItem ::= CONC:o Name:n LBRACKET Name:m RBRACKET LBRACE  RBRACE 
        {:  RESULT = new DashState(o, 
                n.label, 
                m.label, 
                DashStrings.StateKind.AND, 
                DashStrings.DefKind.NOTDEFAULT, 
                DashState.noSubstates());  
        :};

// parametrized state, non-default, substates
StateItem ::= CONC:o Name:n LBRACKET Name:m RBRACKET LBRACE StateItemList:c RBRACE 
         {:  RESULT = new DashState(o, 
                n.label, 
                m.label,
                DashStrings.StateKind.AND, 
                DashStrings.DefKind.NOTDEFAULT, 
                c);  
        :};

// parametrized state, default, empty
StateItem ::= DEF CONC:o Name:n LBRACKET Name:m RBRACKET LBRACE  RBRACE 
        {:  RESULT = new DashState(o, 
                n.label, 
                m.label, 
                DashStrings.StateKind.AND, 
                DashStrings.DefKind.DEFAULT,
                DashState.noSubstates());  
        :};

// parametrized state, default, empty
StateItem ::= DEF CONC:o Name:n LBRACKET Name:m RBRACKET LBRACE StateItemList:c RBRACE 
        {:  RESULT = new DashState(o, 
                n.label, 
                m.label, 
                DashStrings.StateKind.AND, 
                DashStrings.DefKind.DEFAULT,
                c);  
        :};

// event decls
StateItem ::= EVENT:o Names:n LBRACE RBRACE 
        {: ArrayList<String> ll = new ArrayList<String>();
           for (ExprVar x: n) ll.add(x.label);
           RESULT = new DashEventDecls(o, ll,  DashStrings.IntEnvKind.INT);  :};
StateItem ::= ENV EVENT:o Names:n LBRACE RBRACE 
        {: ArrayList<String> ll = new ArrayList<String>();
           for (ExprVar x: n) ll.add(x.label);
           RESULT = new DashEventDecls(o, ll,  DashStrings.IntEnvKind.ENV);  :}; 

// var decls
StateItem ::=
        // we don't support the full variations of declarations here
        // don't know what the pos should be for this one
           Names:n COLON:o Expr:b
        {: ArrayList<String> ll = new ArrayList<String>();
           for (ExprVar x: n) ll.add(x.label);
           RESULT = new DashVarDecls(o, ll ,b, DashStrings.IntEnvKind.INT); :};
StateItem ::= ENV:o Names:n COLON Expr:b
        {: ArrayList<String> ll = new ArrayList<String>();
           for (ExprVar x: n) ll.add(x.label);
           RESULT = new DashVarDecls(o, ll, b, DashStrings.IntEnvKind.ENV); :};

//buffer decls
//we have to know the number of buffers for the open statements,
//which have to be loaded at the beginning of parsing
//Soln: parse twice
//first time stores buffer names, element types in DashSituation
//second time includes the appropriate opens (based on values in DashSituation)
//when do new DashModule() before start parsing
//collection here is the same regardless of parsing pass
StateItem ::= Names:n COLON:o BUF LBRACKET Name:m RBRACKET  
        {: 
           ArrayList<String> ll = new ArrayList<String>();
           Integer startIndex = DashSituation.bufferIndex;
           for (ExprVar x: n) {
                ll.add(x.label);
                // it will do this the same way both passes through parsing
                DashSituation.bufferElements.add(m.label);
                DashSituation.bufferNames.add(x.label);
                DashSituation.bufferIndex++;
           }
           // endIndex is inclusive
           Integer endIndex = DashSituation.bufferIndex - 1;
           RESULT = new DashBufferDecls(o, ll, m.label,  DashStrings.IntEnvKind.INT, startIndex, endIndex); 
        :};
StateItem ::= Names:n COLON:o BUF LBRACKET SIGINT RBRACKET  
        {: 
           ArrayList<String> ll = new ArrayList<String>();
           Integer startIndex = DashSituation.bufferIndex;
           for (ExprVar x: n) {
                ll.add(x.label);
                // it will do this the same way both passes through parsing
                DashSituation.bufferElements.add(DashStrings.intName);
                DashSituation.bufferNames.add(x.label);
                DashSituation.bufferIndex++;
           }
           // endIndex is inclusive
           Integer endIndex = DashSituation.bufferIndex - 1;
           RESULT = new DashBufferDecls(o, ll, DashStrings.intName,  DashStrings.IntEnvKind.INT, startIndex, endIndex); 
        :};
StateItem ::= ENV:o Names:n COLON BUF LBRACKET Name:m RBRACKET  
        {: 
           ArrayList<String> ll = new ArrayList<String>();
           Integer startIndex = DashSituation.bufferIndex;
           for (ExprVar x: n) {
                ll.add(x.label);
                // it will do this the same way both passes through parsing
                DashSituation.bufferElements.add(m.label);
                DashSituation.bufferNames.add(x.label);
                DashSituation.bufferIndex++;
           }
           // endIndex is inclusive
           Integer endIndex = DashSituation.bufferIndex - 1;
           RESULT = new DashBufferDecls(o, ll, m.label,  DashStrings.IntEnvKind.ENV, startIndex, endIndex); 
        :};
StateItem ::= ENV:o Names:n COLON BUF LBRACKET SIGINT RBRACKET  
        {: 
           ArrayList<String> ll = new ArrayList<String>();
           Integer startIndex = DashSituation.bufferIndex;
           for (ExprVar x: n) {
                ll.add(x.label);
                // it will do this the same way both passes through parsing
                DashSituation.bufferElements.add(DashStrings.intName);
                DashSituation.bufferNames.add(x.label);
                DashSituation.bufferIndex++;
           }
           // endIndex is inclusive
           Integer endIndex = DashSituation.bufferIndex - 1;
           RESULT = new DashBufferDecls(o, ll, DashStrings.intName,  DashStrings.IntEnvKind.ENV, startIndex, endIndex); 
        :};

// init
// Super is a list of expressions joined by conjunction
StateItem ::= INIT:o Super:v   
        {: RESULT = new DashInit(o, v); :};

// invariant
StateItem ::= INVARIANT:o Super:v 
        {:  RESULT = new DashInv(o, v); :};

StateItem ::= INVARIANT:o Name:n Super:v 
        {:  RESULT = new DashInv(o, n.label, v); :};

// action
//StateItem ::= ACTION:o Name:n LBRACKET Expr:e RBRACKET LBRACE RBRACE
//        {:  RESULT = new DashAction(o, n.label, e); :};

// condition
//StateItem ::= CONDITION:o Name:n LBRACKET Expr:e RBRACKET LBRACE RBRACE
//        {:  RESULT = new DashCondition(o, n.label, e); :};

// transition
StateItem ::= TRANS:o Name:n LBRACE TransItemList:c RBRACE 
        {: RESULT = new DashTrans(o, n.label, c);  :};  
// transition
StateItem ::= TRANS:o Name:n LBRACE  RBRACE 
        {: RESULT = new DashTrans(o, n.label, new ArrayList<Object>());  :};  

TransItemList ::= TransItem:x
        {: RESULT = new ArrayList<Object>(); RESULT.add(x); :};
TransItemList ::= TransItemList:c TransItem:x   
        {: c.add(x); RESULT = c; :};

//Exprp is non-empty list of comma-separated Expr
//Exprs could be empty ist of comma-separated Expr
TransItem ::= FROM:o Name:n  
        {: RESULT = new DashFrom(o, new DashRef(o, n.label,DashRef.emptyParamValuesList()));  :};

TransItem ::= FROM:o Name:n LBRACKET Exprp:e RBRACKET 
        {: RESULT = new DashFrom(o, new DashRef(o,n.label,e));  :};

TransItem ::= GOTO:o Name:n   
        {: RESULT = new DashGoto(o, new DashRef(o,n.label,DashRef.emptyParamValuesList())); :};

TransItem ::= GOTO:o Name:n LBRACKET  Exprp:e RBRACKET 
        {: 
           RESULT = new DashGoto(o, new DashRef(o, n.label,e));
        :};

// this allows "on x.ev1", "on A/ev1[x]" and "on n" in parsing but will have to sort out later to see if correct
TransItem ::= ON:o Expr:v 
        {: RESULT = new DashOn(o, v); :};

//TransItem ::= ON:o Name:n   
//        {: //RESULT = new DashOn(o, new DashRef(o, n.label,DashRef.emptyParamValuesList()) );  :};

//TransItem ::= ON:o Name:n LBRACKET  Expr:b RBRACKET  
//        {: //RESULT = new DashOn(o, new DashRef(o,n.label,e) );  :};

TransItem ::= WHEN:o Expr:v 
        {:  RESULT = new DashWhen(o, v); :};

TransItem ::= DO:o   Expr:v  
        {:  RESULT = new DashDo(o, v); :};

// this allows Send x.ev1 and "Send n" in parsing but will have to sort out later to see if correct
TransItem ::= SEND:o Expr:v 
        {: RESULT = new DashSend(o, v); :};

//TransItem ::= SEND:o Name:n   
//        {: RESULT = new DashSend(o, new DashRef(o, n.label,DashRef.emptyParamValuesList()) );  :};

//TransItem ::= SEND:o Name:n LBRACKET  Exprp:e RBRACKET  
//        {: RESULT = new DashSend(o, new DashRef(o,n.label,e) );  :};

// DASH PLUS PROCESS REFERENCE
// in Alloy can't have a "/Variable" in the following so we need more syntax
// A/B/C[ParamValue1, ParamValue2]/Variable
// result ParamValue2.ParamValue1.A/B/C/Variable (using BadJoins)
// note PRIME is a special token in grammar and we want to support v'

BracketExprB ::= BracketExprB:a LBRACKET:o Exprs:b RBRACKET SLASH Name:e 
    {: 
        Expr r = ExprVar.make(o, a.toString() + '/' + e.label);
        Collections.reverse(b);
        for (Expr x:b) r = ExprBinary.Op.JOIN.make(o,null, x, r);
        RESULT= ExprBinary.Op.JOIN.make(o, null, DashRef.processRef(), r);
    :}; 
BracketExprB ::= BracketExprB:a LBRACKET:o Exprs:b RBRACKET SLASH Name:e PRIME
    {: 
        Expr r = ExprVar.make(o, a.toString() + '/' + e.label + "'");
        Collections.reverse(b);
        for (Expr x:b) r = ExprBinary.Op.JOIN.make(o,null, x, r);
        RESULT= ExprBinary.Op.JOIN.make(o, null, DashRef.processRef(),r);
    :}; 

//DASH end grammar ---------------------------------------------------------------------

