package ca.uwaterloo.watform.dashtoalloy;

import java.util.Collections;
import java.util.stream.Collectors;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Set;
import java.util.HashSet;

import edu.mit.csail.sdg.ast.Decl;
import edu.mit.csail.sdg.ast.ExprVar;
import edu.mit.csail.sdg.ast.Expr;

import ca.uwaterloo.watform.core.DashOptions;
import static ca.uwaterloo.watform.core.DashStrings.*;
import ca.uwaterloo.watform.core.DashUtilFcns;
import ca.uwaterloo.watform.core.DashRef;
import ca.uwaterloo.watform.core.DashErrors;

// shortens the code to import these statically
import static ca.uwaterloo.watform.core.DashFQN.*;
import static ca.uwaterloo.watform.alloyasthelper.ExprHelper.*;

import ca.uwaterloo.watform.alloyasthelper.DeclExt;
import ca.uwaterloo.watform.alloyasthelper.ExprToString;

import ca.uwaterloo.watform.parser.DashModule;
import ca.uwaterloo.watform.parser.CompModuleHelper;

import static ca.uwaterloo.watform.dashtoalloy.Common.*;

public class AddTransPost {

    /*
    pred post_t1[s,s':Snapshot] {
        forall i: confi' = confi - exitedi + enteredi
        forall i : scopesUsedi' = scopesUsedi + scopesUsed
        action_t1[s,s']
        testIfNextStable[s,s',t1,t1_send_ev] => {
            s'.stable = True
            // empty scopesUsed
            forall i : scopesUsedi' = none
            s.stable = True => {
                // case 1
                // big step = one small step
                // only internal events are those generated by t1
                // allow env events to change
                forall i: eventsi' :> InternalEvents = t1_send_ev (if i)
            } else {
                // case 2
                // last small step of the big step
                // add t1's gen events to the internal events
                // allow env events to change
                forall i: eventsi' :> InternalEvent =
                    t1_send_ev (if i) + (eventsi :> InternalEvent )
            }
        } else {
            stable' = False
            env_vars_unchanged[s,s']
            s.stable = True => {
                // case 3
                // first small step of the big step
                // only internal events are those generated by t1
                forall i: eventsi' :> InternalEvent = t1_send_ev (if i)
                // env events stay the same
                forall i: eventsi' :> EnvironmentalEvent = eventsi :> EnvironmentalEvent
                // empty previous scopes used and just add this one
                forall i : scopesUsedi' = scopesUsed
            } else {
                // case 4
                // intermediate small step
                // add t1's gen event to the events
                // env events don't change
                forall i: eventsi' = eventsi + t1_send_ev (if i)
                // just add to scopesUsed
                forall i : scopesUsedi' = scopesUsedi + scopesUsed
            }
        }
    }
    */

    // TODO for Electrum!
    public static void addTransPost(DashModule d, String tfqn) {
        String tout = translateFQN(tfqn);
        List<Integer> prsIdx = d.getTransParamsIdx(tfqn); 
        List<String> prs = d.getTransParams(tfqn);
        List<Expr> body = new ArrayList<Expr>();

        // confi' = confi - exitedi + enteredi
        List<DashRef> entered = d.entered(tfqn);
        List<DashRef> exited = d.exited(tfqn);
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            List<Expr> ent = DashRef.hasNumParams(entered,i).stream()
                .map(x -> translateDashRefToArrow(x))
                .collect(Collectors.toList());
            List<Expr> exi = DashRef.hasNumParams(exited,i).stream()
                .map(x -> translateDashRefToArrow(x))
                .collect(Collectors.toList());
            Expr e = curConf(i);
            for (Expr x:exi) {
                // can't diff ((ent1 - ent2) - ent3)
                // but have to diff from whole set
                e = createDiff(e,x);
            }
            //if (!exi.isEmpty()) e = createDiff(e,createDiffList(exi));
            if (!ent.isEmpty()) e = createUnion(e,createUnionList(ent));
            body.add(createEquals(nextConf(i),e));
        }

        // action_t1[s,s']
        if (d.getTransDo(tfqn) != null)
            body.add(translateExpr(d.getTransDo(tfqn),d));

        // vars not mentioned in action do not change
        // includes entered/exited
        Set<String> intVarsThatDontChange = DashUtilFcns.listToSet(d.getAllInternalVarNames());
        // TODO buffers?

        // remove variables mentioned in invariants
        // whether they are primed or not
        for (Expr i:d.getInvs()) {
            List<DashRef> primedDashRefs = d.primedDashRefs(i);
            for (DashRef r:primedDashRefs) {
                intVarsThatDontChange.remove(r.getName());
            }
        }

        // separate primed variables in transitions into those
        // that we can't put any constraints on (remove these from intVarsThatDontChange)
        // and those that we constrain the sister value os (sistersDontChange)
        Set<String> sistersDontChange = new HashSet<String>();
        if (d.getTransDo(tfqn) != null) {
            for (DashRef r: d.primedDashRefs(d.getTransDo(tfqn))) {
                //System.out.println(r);
                if (r.getParamValues().isEmpty()) intVarsThatDontChange.remove(r.getName());
                else if (hasSpecificParamValues(d, r)) {
                    //System.out.println("has specific param values");
                    intVarsThatDontChange.remove(r.getName());
                    // might not be in sistersDontChange
                    sistersDontChange.remove(r.getName());
                } else {
                    //System.out.println("has generic param values");
                    // has generic param values
                    sistersDontChange.add(r.getName());
                    intVarsThatDontChange.remove(r.getName());
                }
            }
        }
        //System.out.println(tfqn);
        //System.out.println(sistersDontChange);
        List<Decl> decls;
        List<Expr> args;

        // constraints on sister elements
        for (String x: sistersDontChange) {
            decls = new ArrayList<Decl>();
            args = new ArrayList<Expr>();
            List<Integer> paramsIdx = d.getVarBufferParamsIdx(x);
            List<String> params = d.getVarBufferParams(x);
            for (int i=0; i < params.size();i++) {
                String p = params.get(i);
                decls.add(new DeclExt(p + randomParamExt, 
                    createDiff(createVar(p), paramVar(paramsIdx.get(i), p))));
                args.add(createVar(p + randomParamExt));
            }
            if (decls.isEmpty()) DashErrors.sistersDontChangeDoesNotHaveParams(x);
            else body.add(createAll(decls,
                createEquals(
                    createJoinList(args, curJoinExpr(createVar(translateFQN(x)))),
                    createJoinList(args, nextJoinExpr(createVar(translateFQN(x)))))));
        }
        

        // constraint on untouched vars 
        for (String x:intVarsThatDontChange) {
            decls = new ArrayList<Decl>();
            args = new ArrayList<Expr>();
            for (String p: d.getVarBufferParams(x)) {
                decls.add(new DeclExt(p + randomParamExt, p));
                args.add(createVar(p + randomParamExt));
            }
            if (decls.isEmpty()) body.add(createEquals(
                    curJoinExpr(createVar(translateFQN(x))), 
                    nextJoinExpr(createVar(translateFQN(x)))));
            else body.add(createAll(decls, createEquals(
                    createJoinList(args, curJoinExpr(createVar(translateFQN(x)))),
                    createJoinList(args, nextJoinExpr(createVar(translateFQN(x)))))));
        }


        DashRef ev = d.getTransSend(tfqn);
        Expr rhs, rhs1, q;

        // case 1
        // forall i. eventsi' :> InternalEvents = t1_send (if i)
        //           eventsi' :> InternalEvents = none (if not i)  
        List<Expr> case1 = new ArrayList<Expr>();    
        Expr c1; 
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            if (d.hasInternalEventsAti(i)) {
                if (ev != null && ev.getParamValues().size() == i) rhs = translateDashRefToArrow(ev);
                else rhs = createNoneArrow(i);
                case1.add(createEquals(
                    createRangeRes(nextEvents(i),allInternalEventsVar()),
                    rhs));
            }
        }
        //if (case1.isEmpty()) c1 = createTrue();
        c1 = createAndFromList(case1);

        // case 2
        // forall i. eventsi' :> InternalEvents = t1_send_ev (if i) + eventsi 
        //           eventsi' :> InternalEvents = eventsi (if not i)       
        List<Expr> case2 = new ArrayList<Expr>();   
        Expr c2;
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            if (d.hasInternalEventsAti(i)) {
                q = createRangeRes(curEvents(i), allInternalEventsVar());
                if (ev != null && ev.getParamValues().size() == i) rhs = createUnion(translateDashRefToArrow(ev), q);
                else rhs = q;
                case2.add(createEquals(
                            createRangeRes(nextEvents(i),allInternalEventsVar()),
                            rhs));
            }
        }
        //if (case2.isEmpty()) c2 = createTrue();
        c2 = createAndFromList(case2);

        List<Expr> scopesUsedEmpty = new ArrayList<Expr>();
        
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            scopesUsedEmpty.add(createEquals(nextScopesUsed(i),createNoneArrow(i)));
        }
        Expr stableTrueAndScopesUsedEmpty = 
            createAnd(nextStableTrue(), createAndFromList(scopesUsedEmpty));

        // case 3
        // forall i: (eventsi' :> InternalEvent = t1_send_ev (if i))
        //           (eventsi' :> InternalEvent = none) (if not i)
        //       and (eventsi' :> EnvironmentalEvent = eventsi :> EnvironmentalEvent)
        List<Expr> case3 = new ArrayList<Expr>();  
        Expr c3;
        // have to be initialized to something
        Expr intEvExpr = createNone();
        Expr envEvExpr = createNone(); 
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            if (d.hasInternalEventsAti(i)) {
                if (ev != null && ev.getParamValues().size() == i) rhs1 = translateDashRefToArrow(ev);
                else rhs1 = createNoneArrow(i);
                intEvExpr = createEquals(
                                    createRangeRes(nextEvents(i),allInternalEventsVar()), 
                                    rhs1);
            }
            if (d.hasEnvironmentalEventsAti(i)) {
                envEvExpr = createEquals(
                                    createRangeRes(nextEvents(i),allEnvironmentalEventsVar()),
                                    createRangeRes(curEvents(i),allEnvironmentalEventsVar()) );
            }
            if (d.hasInternalEventsAti(i)) {
                if (d.hasEnvironmentalEventsAti(i)) case3.add(createAnd(intEvExpr, envEvExpr));
                else case3.add(intEvExpr);
            } else {
                if (d.hasEnvironmentalEventsAti(i)) case3.add(envEvExpr);
            }
            case3.add(createEquals(nextScopesUsed(i),createNoneArrow(i)));
        }
        //if (case3.isEmpty()) c3 = createTrue();
        c3 = createAndFromList(case3);

        // case 4
        // forall i. eventsi' = eventsi + t1_send (if i)
        //           eventsi' = eventsi (if not i)
        List<Expr> case4 = new ArrayList<Expr>();  
        List<DashRef> sU = d.scopesUsed(tfqn);
        List<Expr> u;
        Expr e;
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            if (d.hasEventsAti(i)) {
                if (ev != null && ev.getParamValues().size() == i) 
                    case4.add(createEquals(nextEvents(i),createUnion(curEvents(i), translateDashRefToArrow(ev))));
            }
            // scopesUsedi' = scopesUsedi + scopesUsed
            u = DashRef.hasNumParams(sU,i).stream()
                .map(x -> translateDashRefToArrow(x))
                .collect(Collectors.toList());
            e = curScopesUsed(i);
            if (!u.isEmpty()) e = createUnion(e,createUnionFromList(u));
            case4.add(createEquals(nextScopesUsed(i),e));
        }

        //if (case4.isEmpty()) c4 = createTrue();
        Expr c4 = createAndFromList(case4);

        // env_vars_unchanged[s,s']
        
        List<String> allVarBuffers = d.getAllVarNames();
        allVarBuffers.addAll(d.getAllBufferNames());
        // might just return true if allVarBuffers is empty
        Expr envNoChange = createAndFromList(allVarBuffers.stream()
                .filter(i -> !d.isInternal(i))
                .map(i -> createVarDoesNotChange(d, i))
                .collect(Collectors.toList()));
        Expr stableFalseAndEnvNoChange = createAnd(nextStableFalse(), envNoChange);

        // big ITE is simplified for boolean/True, boolean/False
        // b/c Alloy does not allow those as "formulas"
        if (d.hasConcurrency())
            body.add(
            createITE(createTestIfNextStableCall(d, tfqn),
                createAnd(
                    stableTrueAndScopesUsedEmpty,
                    createITE (curStableTrue(),
                        c1,
                        c2)),
                createAnd(
                    stableFalseAndEnvNoChange,
                    createITE(curStableTrue(),
                        c3,
                        c4))));
        

        d.alloyString += d.addPredSimple(tout+postName,curNextParamsDecls(prsIdx,prs),body);
    }

    public static Expr createVarDoesNotChange(DashModule d, String x) {
        Expr e = createEquals(
                    createJoinList(DashUtilFcns.newListWith(curParamVars(d.getVarBufferParamsIdx(x), d.getVarBufferParams(x)),createVar(translateFQN(x)))),
                    createJoinList(DashUtilFcns.newListWith(nextParamVars(d.getVarBufferParamsIdx(x), d.getVarBufferParams(x)),createVar(translateFQN(x)))));
        if (d.getVarBufferParamsIdx(x).isEmpty()) return e;
        else return createAll(paramDecls(d.getVarBufferParamsIdx(x),d.getAllParamsInOrder()),e);
    }

    // pred call: testIfNextStable[s,s',scope1, scope2, ... , send1, send2, ...] 
    // where scopei, evi is "none" if this transition's scope and send event 
    private static Expr createTestIfNextStableCall(DashModule d, String tfqn) {
        List<Expr> args = new ArrayList<Expr>();
        if (!DashOptions.isElectrum) {
            args.add(curVar());
            args.add(nextVar());
        }
        // add args for parameters; has to be something or none for every possible parameter in the system
        List<Integer> paramsIdxUsed = d.getTransParamsIdx(tfqn);
        for (int i=0;i<d.getAllParamsInOrder().size();i++) {
            if (paramsIdxUsed.contains(i)) args.add(paramVar(i, d.getAllParamsInOrder().get(i)));
            else args.add(createNone());
        }
        // add scopesUsed and events parameters
        // need scopesUsed and events because the values for both depend on whether next is stable or not
        List<DashRef> sU = d.scopesUsed(tfqn);
        DashRef ev = d.getTransSend(tfqn);
        for (int i=0; i <= d.getMaxDepthParams(); i++) {
            //TODO could only have scopesUsedi for i that has scopesUsed
            List<Expr> u = DashRef.hasNumParams(sU,i).stream()
                .map(x -> translateDashRefToArrow(x))
                .collect(Collectors.toList());
            if (u.size() == 1) args.add(u.get(0));
            else if (u.size() ==0 ) args.add(createNoneArrow(i));
            else { DashErrors.createTestIfNextStableCallMultipleScopesAtSameLevel(); return null; }
            if (d.hasEventsAti(i)) {
                if (ev != null && ev.getParamValues().size() == i) args.add(translateDashRefToArrow(ev));
                else args.add(createNoneArrow(i));
            }
        }
        return createPredCall(testIfNextStableName,args);
    }

    private static boolean hasSpecificParamValues(DashModule d, DashRef r) {
        // only for variables
        //TODO buffers??
        List<Expr> genericPValues = paramVars(d.getVarBufferParamsIdx(r.getName()), d.getVarBufferParams(r.getName()));
        List<Expr> actualPValues = r.getParamValues();
        Boolean ret = false;
        if (genericPValues.size() == actualPValues.size()) {
            for (int i=0; i < genericPValues.size(); i++) {
                //System.out.println("generic: " + genericPValues.get(i));
                //System.out.println("actual: " + actualPValues.get(i));
                if (!sEquals(genericPValues.get(i), actualPValues.get(i))) ret = ret || true;
            }
        } else DashErrors.hasSpecificParamValues();
        return ret;
    }
}