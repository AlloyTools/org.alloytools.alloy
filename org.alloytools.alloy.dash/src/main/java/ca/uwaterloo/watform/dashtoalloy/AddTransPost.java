package ca.uwaterloo.watform.dashtoalloy;

import java.util.Collections;
import java.util.stream.Collectors;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

import edu.mit.csail.sdg.ast.Decl;
import edu.mit.csail.sdg.ast.ExprVar;
import edu.mit.csail.sdg.ast.Expr;

import ca.uwaterloo.watform.core.DashOptions;
import static ca.uwaterloo.watform.core.DashStrings.*;
import ca.uwaterloo.watform.core.DashUtilFcns;
import ca.uwaterloo.watform.core.DashRef;
import ca.uwaterloo.watform.core.DashErrors;

// shortens the code to import these statically
import static ca.uwaterloo.watform.core.DashFQN.*;
import static ca.uwaterloo.watform.alloyasthelper.ExprHelper.*;

import ca.uwaterloo.watform.alloyasthelper.DeclExt;
import ca.uwaterloo.watform.alloyasthelper.ExprToString;

import ca.uwaterloo.watform.parser.DashModule;
import ca.uwaterloo.watform.parser.CompModuleHelper;

import static ca.uwaterloo.watform.dashtoalloy.Common.*;

public class AddTransPost {

    /*
    pred post_t1[s,s':Snapshot] {
        forall i: confi' = confi - exitedi + enteredi
        forall i : scopesUsedi' = scopesUsedi + scopesUsed
        action_t1[s,s']
        testIfNextStable[s,s',t1,t1_send_ev] => {
            s'.stable = True
            s.stable = True => {
                // case 1
                // big step = one small step
                // only internal events are those generated by t1
                // allow env events to change
                forall i: eventsi' & InternalEvents = t1_send_ev (if i)
            } else {
                // case 2
                // last small step of the big step
                // add t1's gen events to the internal events
                // allow env events to change
                forall i: eventsi' & InternalEvent =
                    t1_send_ev (if i) + (InternalEvent & eventsi)
            }
        } else {
            stable' = False
            env_vars_unchanged[s,s']
            s.table = True => {
                // case 3
                // first small step of the big step
                // only internal events are those generated by t1
                forall i: eventsi' & InternalEvent = t1_send_ev (if i)
                // env events stay the same
                eventsi' & EnvironmentlEvent = eventsi & EnvironmentalEvent
            } else {
                // case 4
                // intermediate small step
                // add t1's gen event to the events
                // env events don't change
                forall i: eventsi' = events + t1_send_ev (if i)
            }
        }
    }
    */

    public static void addTransPost(DashModule d, String tfqn) {
        String tout = translateFQN(tfqn);
        List<String> prs = d.getTransParams(tfqn); 
        List<Expr> body = new ArrayList<Expr>();

        // confi' = confi - exitedi + enteredi
        List<DashRef> entered = d.entered(tfqn);
        List<DashRef> exited = d.exited(tfqn);
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            List<Expr> ent = DashRef.hasNumParams(entered,i).stream()
                .map(x -> translateDashRef(x))
                .collect(Collectors.toList());
            List<Expr> exi = DashRef.hasNumParams(exited,i).stream()
                .map(x -> translateDashRef(x))
                .collect(Collectors.toList());
            Expr e = curConf(i);
            if (!exi.isEmpty()) e = createDiff(e,createDiffList(exi));
            if (!ent.isEmpty()) e = createUnion(e,createUnionList(ent));
            body.add(createEquals(nextConf(i),e));
        }
        // scopesUsedi' = scopesUsedi + scopesUsed
        List<DashRef> sU = d.scopesUsed(tfqn);
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            List<Expr> u = DashRef.hasNumParams(sU,i).stream()
                .map(x -> translateDashRef(x))
                .collect(Collectors.toList());
            Expr e = curScopesUsed(i);
            if (!u.isEmpty()) e = createUnion(e,createUnionFromList(u));
            e = createEquals(nextScopesUsed(i),e);
        }

        if (d.getTransDo(tfqn) != null)
            body.add(translateExpr(d.getTransDo(tfqn),d));

        DashRef ev = d.getTransSend(tfqn);
        Expr rhs, rhs1, q;

        // case 1
        // forall i. eventsi' & AllInternalEvents = t1_send (if i)
        //           eventsi' & AllIntermalEvents = none (if not i)  
        List<Expr> case1 = new ArrayList<Expr>();    
        Expr c1; 
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            if (d.hasEventsAti(i)) {
                if (ev != null && ev.getParamValues().size() == i) rhs = translateDashRef(ev);
                else rhs = createNone();
                case1.add(createEquals(
                    createIntersect(nextEvents(i),allInternalEventsVar()),
                    rhs));
            }
        }
        if (case1.isEmpty()) c1 = createTrue();
        else c1 = createAndFromList(case1);

        // case 2
        // forall i: eventsi' & InternalEvent = t1_send_ev (if i) + (InternalEvent & eventsi)           
        List<Expr> case2 = new ArrayList<Expr>();   
        Expr c2;
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            if (d.hasEventsAti(i)) {
                q = createIntersect(allInternalEventsVar(), curEvents(i));
                if (ev != null && ev.getParamValues().size() == i) rhs = createUnion(translateDashRef(ev), q);
                else rhs = q;
                case2.add(createEquals(
                            createIntersect(nextEvents(i),allInternalEventsVar()),
                            rhs));
            }
        }
        if (case2.isEmpty()) c2 = createTrue();
        else c2 = createAndFromList(case2);

        // case 3
        // forall i: (eventsi' & InternalEvent = t1_send_ev (if i))
        //           (eventsi' & InternalEvent = none) (if not i)
        //       and (eventsi' & EnvironmentalEvent = eventsi & EnvironmentalEvent)
        List<Expr> case3 = new ArrayList<Expr>();  
        Expr c3; 
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            if (d.hasEventsAti(i)) {
                if (ev != null && ev.getParamValues().size() == i) rhs1 = translateDashRef(ev);
                else rhs1 = createNone();
                case3.add(createAnd(
                        createEquals(
                            createIntersect(nextEvents(i),allInternalEventsVar()), 
                            rhs1),
                        createEquals(
                            createIntersect(nextEvents(i),allEnvironmentalEventsVar()),
                            createIntersect(curEvents(i),allEnvironmentalEventsVar()) )));
            }
        }
        if (case3.isEmpty()) c3 = createTrue();
        else c3 = createAndFromList(case3);

        // case 4
        // forall i. eventsi' = eventsi + t1_send (if i)
        //           eventsi' = eventsi (if not i)
        List<Expr> case4 = new ArrayList<Expr>();  
        Expr c4; 
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            if (d.hasEventsAti(i)) {
                if (ev != null && ev.getParamValues().size() == i) 
                    case4.add(createEquals(nextEvents(i),createUnion(curEvents(i), translateDashRef(ev))));
            }
        }
        if (case4.isEmpty()) c4 = createTrue();
        else c4 = createAndFromList(case4);

        if (d.hasConcurrency())
            body.add(
            createITE(createTestIfNextStableCall(d, tfqn),
                createAnd(
                    nextStableTrue(),
                    createITE (curStableTrue(),
                        c1,
                        c2)),
                createAnd(
                    nextStableFalse(),
                    createITE(curStableTrue(),
                        c3,
                        c4))));
        else 
            body.add(
                createAnd(nextStableTrue(), c1));

        d.alloyString += d.addPredSimple(tout+postName,curNextParamsDecls(prs),body);
    }

    // pred call: testIfNextStable[s,s',scope1, scope2, ... , send1, send2, ...] 
    // where scopei, evi is "none" if this transition's scope and send event 
    private static Expr createTestIfNextStableCall(DashModule d, String tfqn) {
        List<Expr> args = new ArrayList<Expr>();
        if (!DashOptions.isElectrum) {
            args.add(curVar());
            args.add(nextVar());
        }
        List<DashRef> sU = d.scopesUsed(tfqn);
        DashRef ev = d.getTransSend(tfqn);
        for (int i=0; i <= d.getMaxDepthParams(); i++) {
            //TODO could only have scopesUsedi for i that has scopesUsed
            List<Expr> u = DashRef.hasNumParams(sU,i).stream()
                .map(x -> translateDashRef(x))
                .collect(Collectors.toList());
            if (u.size() == 1) args.add(u.get(0));
            else if (u.size() ==0 ) args.add(createNone());
            else { DashErrors.createTestIfNextStableCallMultipleScopesAtSameLevel(); return null; }
            if (d.hasEventsAti(i)) {
                if (ev != null && ev.getParamValues().size() == i) args.add(translateDashRef(ev));
                else args.add(createNone());
            }
        }
        return createPredCall(testIfNextStableName,args);
    }

}