package ca.uwaterloo.watform.dashtoalloy;

import java.util.Collections;
import java.util.stream.Collectors;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

import edu.mit.csail.sdg.ast.Decl;
import edu.mit.csail.sdg.ast.ExprVar;
import edu.mit.csail.sdg.ast.Expr;

import ca.uwaterloo.watform.core.DashOptions;
import static ca.uwaterloo.watform.core.DashStrings.*;
import ca.uwaterloo.watform.core.DashUtilFcns;
import ca.uwaterloo.watform.core.DashRef;
import ca.uwaterloo.watform.core.DashErrors;

// shortens the code to import these statically
import static ca.uwaterloo.watform.core.DashFQN.*;
import static ca.uwaterloo.watform.alloyasthelper.ExprHelper.*;

import ca.uwaterloo.watform.alloyasthelper.DeclExt;
import ca.uwaterloo.watform.alloyasthelper.ExprToString;

import ca.uwaterloo.watform.parser.DashModule;
import ca.uwaterloo.watform.parser.CompModuleHelper;

import static ca.uwaterloo.watform.dashtoalloy.Common.*;

public class AddTransPost {

    /*
    pred post_t1[s,s':Snapshot] {
        forall i: confi' = confi - exitedi + enteredi
        forall i : scopesUsedi' = scopesUsedi + scopesUsed
        action_t1[s,s']
        testIfNextStable[s,s',t1,t1_send_ev] => {
            s'.stable = True
            // empty scopesUsed
            forall i : scopesUsedi' = none
            s.stable = True => {
                // case 1
                // big step = one small step
                // only internal events are those generated by t1
                // allow env events to change
                forall i: eventsi' & InternalEvents = t1_send_ev (if i)
            } else {
                // case 2
                // last small step of the big step
                // add t1's gen events to the internal events
                // allow env events to change
                forall i: eventsi' & InternalEvent =
                    t1_send_ev (if i) + (InternalEvent & eventsi)
            }
        } else {
            stable' = False
            env_vars_unchanged[s,s']
            s.stable = True => {
                // case 3
                // first small step of the big step
                // only internal events are those generated by t1
                forall i: eventsi' & InternalEvent = t1_send_ev (if i)
                // env events stay the same
                eventsi' & EnvironmentlEvent = eventsi & EnvironmentalEvent
                // empty previous scopes used and just add this one
                forall i : scopesUsedi' = scopesUsed
            } else {
                // case 4
                // intermediate small step
                // add t1's gen event to the events
                // env events don't change
                forall i: eventsi' = events + t1_send_ev (if i)
                // just add to scopesUsed
                forall i : scopesUsedi' = scopesUsedi + scopesUsed
            }
        }
    }
    */

    // TODO for Electrum!
    public static void addTransPost(DashModule d, String tfqn) {
        String tout = translateFQN(tfqn);
        List<Integer> prsIdx = d.getTransParamsIdx(tfqn); 
        List<String> prs = d.getTransParams(tfqn);
        List<Expr> body = new ArrayList<Expr>();

        // confi' = confi - exitedi + enteredi
        List<DashRef> entered = d.entered(tfqn);
        List<DashRef> exited = d.exited(tfqn);
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            List<Expr> ent = DashRef.hasNumParams(entered,i).stream()
                .map(x -> translateDashRefToArrow(x))
                .collect(Collectors.toList());
            List<Expr> exi = DashRef.hasNumParams(exited,i).stream()
                .map(x -> translateDashRefToArrow(x))
                .collect(Collectors.toList());
            Expr e = curConf(i);
            for (Expr x:exi) {
                // can't diff ((ent1 - ent2) - ent3)
                // but have to diff from whole set
                e = createDiff(e,x);
            }
            //if (!exi.isEmpty()) e = createDiff(e,createDiffList(exi));
            if (!ent.isEmpty()) e = createUnion(e,createUnionList(ent));
            body.add(createEquals(nextConf(i),e));
        }

        // action_t1[s,s']
        if (d.getTransDo(tfqn) != null)
            body.add(translateExpr(d.getTransDo(tfqn),d));

        DashRef ev = d.getTransSend(tfqn);
        Expr rhs, rhs1, q;

        // case 1
        // forall i. eventsi' :> InternalEvents = t1_send (if i)
        //           eventsi' :> InternalEvents = none (if not i)  
        List<Expr> case1 = new ArrayList<Expr>();    
        Expr c1; 
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            if (d.hasEventsAti(i)) {
                if (ev != null && ev.getParamValues().size() == i) rhs = translateDashRefToArrow(ev);
                else rhs = createNoneArrow(i);
                case1.add(createEquals(
                    createRangeRes(nextEvents(i),allInternalEventsVar()),
                    rhs));
            }
        }
        //if (case1.isEmpty()) c1 = createTrue();
        c1 = createAndFromList(case1);

        // case 2
        // forall i. eventsi' :> InternalEvents = t1_send_ev (if i) + eventsi 
        //           eventsi' :> InternalEvents = eventsi (if not i)       
        List<Expr> case2 = new ArrayList<Expr>();   
        Expr c2;
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            if (d.hasEventsAti(i)) {
                q = createRangeRes(curEvents(i), allInternalEventsVar());
                if (ev != null && ev.getParamValues().size() == i) rhs = createUnion(translateDashRefToArrow(ev), q);
                else rhs = q;
                case2.add(createEquals(
                            createRangeRes(nextEvents(i),allInternalEventsVar()),
                            rhs));
            }
        }
        //if (case2.isEmpty()) c2 = createTrue();
        c2 = createAndFromList(case2);

        List<Expr> scopesUsedEmpty = new ArrayList<Expr>();
        
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            scopesUsedEmpty.add(createEquals(nextScopesUsed(i),createNone()));
        }
        Expr stableTrueAndScopesUsedEmpty = 
            createAnd(nextStableTrue(), createAndFromList(scopesUsedEmpty));

        // case 3
        // forall i: (eventsi' :> InternalEvent = t1_send_ev (if i))
        //           (eventsi' :> InternalEvent = none) (if not i)
        //       and (eventsi' :> EnvironmentalEvent = eventsi :> EnvironmentalEvent)
        List<Expr> case3 = new ArrayList<Expr>();  
        Expr c3; 
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            if (d.hasEventsAti(i)) {
                if (ev != null && ev.getParamValues().size() == i) rhs1 = translateDashRefToArrow(ev);
                else rhs1 = createNoneArrow(i);
                if (d.hasEnvironmentalEvents()) 
                    case3.add(createAnd(
                            createEquals(
                                createRangeRes(nextEvents(i),allInternalEventsVar()), 
                                rhs1),
                            createEquals(
                                createRangeRes(nextEvents(i),allEnvironmentalEventsVar()),
                                createRangeRes(curEvents(i),allEnvironmentalEventsVar()) )));
                else 
                    case3.add(createEquals(
                                createRangeRes(nextEvents(i),allInternalEventsVar()), 
                                rhs1));
            }
            case3.add(createEquals(nextScopesUsed(i),createNone()));
        }
        //if (case3.isEmpty()) c3 = createTrue();
        c3 = createAndFromList(case3);

        // case 4
        // forall i. eventsi' = eventsi + t1_send (if i)
        //           eventsi' = eventsi (if not i)
        List<Expr> case4 = new ArrayList<Expr>();  
        List<DashRef> sU = d.scopesUsed(tfqn);
        List<Expr> u;
        Expr e;
        for (int i=0;i <= d.getMaxDepthParams(); i++) {
            if (d.hasEventsAti(i)) {
                if (ev != null && ev.getParamValues().size() == i) 
                    case4.add(createEquals(nextEvents(i),createUnion(curEvents(i), translateDashRefToArrow(ev))));
            }
            // scopesUsedi' = scopesUsedi + scopesUsed
            u = DashRef.hasNumParams(sU,i).stream()
                .map(x -> translateDashRefToArrow(x))
                .collect(Collectors.toList());
            e = curScopesUsed(i);
            if (!u.isEmpty()) e = createUnion(e,createUnionFromList(u));
            case4.add(createEquals(nextScopesUsed(i),e));
        }

        //if (case4.isEmpty()) c4 = createTrue();
        Expr c4 = createAndFromList(case4);

        // env_vars_unchanged[s,s']
        
        List<String> allVarBuffers = d.getAllVarNames();
        allVarBuffers.addAll(d.getAllBufferNames());
        // might just return true if allVarBuffers is empty
        Expr envNoChange = createAndFromList(allVarBuffers.stream()
                .filter(i -> !d.isInternal(i))
                .map(i -> createVarDoesNotChange(d, i))
                .collect(Collectors.toList()));
        Expr stableFalseAndEnvNoChange = createAnd(nextStableFalse(), envNoChange);

        // big ITE is simplified for boolean/True, boolean/False
        // b/c Alloy does not allow those as "formulas"
        if (d.hasConcurrency())
            body.add(
            createITE(createTestIfNextStableCall(d, tfqn),
                createAnd(
                    stableTrueAndScopesUsedEmpty,
                    createITE (curStableTrue(),
                        c1,
                        c2)),
                createAnd(
                    stableFalseAndEnvNoChange,
                    createITE(curStableTrue(),
                        c3,
                        c4))));
        

        d.alloyString += d.addPredSimple(tout+postName,curNextParamsDecls(prsIdx,prs),body);
    }

    public static Expr createVarDoesNotChange(DashModule d, String x) {
        return createAll(
                paramDecls(d.getVarBufferParamsIdx(x),d.getAllParamsInOrder()),
                createEquals(
                    createJoinList(DashUtilFcns.newListWith(curParamVars(d.getVarBufferParamsIdx(x), d.getVarBufferParams(x)),createVar(x))),
                    createJoinList(DashUtilFcns.newListWith(nextParamVars(d.getVarBufferParamsIdx(x), d.getVarBufferParams(x)),createVar(x)))));
    }

    // pred call: testIfNextStable[s,s',scope1, scope2, ... , send1, send2, ...] 
    // where scopei, evi is "none" if this transition's scope and send event 
    private static Expr createTestIfNextStableCall(DashModule d, String tfqn) {
        List<Expr> args = new ArrayList<Expr>();
        if (!DashOptions.isElectrum) {
            args.add(curVar());
            args.add(nextVar());
        }
        // add args for parameters; has to be something or none for every possible parameter in the system
        List<Integer> paramsIdxUsed = d.getTransParamsIdx(tfqn);
        for (int i=0;i<d.getAllParamsInOrder().size();i++) {
            if (paramsIdxUsed.contains(i)) args.add(paramVar(i, d.getAllParamsInOrder().get(i)));
            else args.add(createNone());
        }
        // add scopesUsed and events parameters
        // need scopesUsed and events because the values for both depend on whether next is stable or not
        List<DashRef> sU = d.scopesUsed(tfqn);
        DashRef ev = d.getTransSend(tfqn);
        for (int i=0; i <= d.getMaxDepthParams(); i++) {
            //TODO could only have scopesUsedi for i that has scopesUsed
            List<Expr> u = DashRef.hasNumParams(sU,i).stream()
                .map(x -> translateDashRefToArrow(x))
                .collect(Collectors.toList());
            if (u.size() == 1) args.add(u.get(0));
            else if (u.size() ==0 ) args.add(createNone());
            else { DashErrors.createTestIfNextStableCallMultipleScopesAtSameLevel(); return null; }
            if (d.hasEventsAti(i)) {
                if (ev != null && ev.getParamValues().size() == i) args.add(translateDashRefToArrow(ev));
                else args.add(createNoneArrow(i));
            }
        }
        return createPredCall(testIfNextStableName,args);
    }

}